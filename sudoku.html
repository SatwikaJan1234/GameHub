<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Matrix Reasoning â€“ Pick the Missing Picture</title>
<style>
  :root{
    --bg1:#1b2042;--bg2:#0f1222;
    --card:#161a2c;--ink:#e7e9ff;--muted:#a8b0d3;
    --accent:#6ae3ff;--accent2:#77ff9b;--wrong:#ff6b6b;--right:#5bd39c;
    --radius:16px;--shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; display:grid; place-items:center;
    background: radial-gradient(1200px 600px at 20% -10%, var(--bg1), var(--bg2));
    color:var(--ink); font:500 16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial;
    padding:18px;
  }
  
  .app{width:min(1050px,94vw)}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;margin-bottom:12px}
  .brand{display:flex;align-items:center;gap:10px}
  .dot{width:14px;height:14px;border-radius:50%;background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 0 0 4px rgba(106,227,255,.15)}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  select,button{
    background:var(--card);color:var(--ink);border:1px solid rgba(255,255,255,.08);
    padding:10px 12px;border-radius:12px;outline:none;transition:.2s ease;
    box-shadow:inset 0 -12px 20px rgba(255,255,255,.02); cursor:pointer;
  }
  button.primary{background:linear-gradient(135deg,var(--accent),var(--accent2));color:#001720;border:none;font-weight:700}
  button:hover,select:hover{transform:translateY(-1px);box-shadow:0 8px 18px rgba(0,0,0,.25)}

  .layout{display:grid;grid-template-columns: 1fr 320px; gap:18px; margin-top:12px}
  @media (max-width: 920px){ .layout{grid-template-columns:1fr} }

  .card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0)); padding:16px;
        border:1px solid rgba(255,255,255,.08); border-radius:var(--radius); box-shadow:var(--shadow)}

  .grid{
    display:grid; grid-template-columns:repeat(3,1fr); gap:10px;
  }
  .tile{
    background:#0a0c18;border:1px solid rgba(255,255,255,.08); border-radius:12px;
    display:grid; place-items:center; aspect-ratio:1; position:relative; overflow:hidden;
  }
  canvas{width:100%; height:100%}
  .missing::after{
    content:"?"; position:absolute; inset:0; display:grid; place-items:center;
    font-weight:900; font-size:48px; color:#ffd166; background:rgba(255,255,255,.03);
    text-shadow:0 2px 16px rgba(0,0,0,.5);
  }

  .options{display:grid; grid-template-columns:repeat(2,1fr); gap:10px}
  .opt{
    border:1px solid rgba(255,255,255,.08); border-radius:12px; overflow:hidden; background:#0b1022;
    transition:.15s ease; position:relative;
  }
  .opt:active{transform:scale(.98)}
  .opt.correct{outline:3px solid var(--right)}
  .opt.wrong{outline:3px solid var(--wrong)}
  .label{
    position:absolute; top:6px; left:8px; font-weight:800; font-size:14px; color:#a8b0d3; opacity:.9
  }

  .stat{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;background:var(--card);
        border-radius:12px;border:1px solid rgba(255,255,255,.08); margin-bottom:10px}
  .muted{color:var(--muted)}
  .legend{display:flex; gap:8px; flex-wrap:wrap; font-size:13px; color:var(--muted)}
  .tag{background:#0f1326;border:1px solid rgba(255,255,255,.08); padding:6px 8px;border-radius:8px}
  .footer{text-align:center;color:var(--muted);font-size:13px;margin-top:10px}

  /* Touch niceties */
  .options, .grid { touch-action: manipulation; }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand"><span class="dot"></span><strong>Matrix Reasoning</strong></div>
      <div class="controls">
        <label class="muted">Rule Mix</label>
        <select id="mode">
          <option value="mixed" selected>Mixed</option>
          <option value="shapeColor">Shape + Color</option>
          <option value="shapeRotate">Shape + Rotation</option>
          <option value="sizeColor">Size + Color</option>
        </select>
        <button class="primary" id="nextBtn">Next Puzzle</button>
      </div>
    </header>

    <div class="layout">
      <section class="card">
        <div class="stat"><span>Puzzle</span><strong id="puzNo">1</strong></div>
        <div id="board" class="grid" aria-label="3 by 3 puzzle grid"></div>
      </section>

      <aside class="side">
        <div class="card stat"><span>Time</span><strong id="timer">00:00</strong></div>
        <div class="card stat"><span>Score</span><strong><span id="score">0</span> correct</strong></div>

        <div class="card">
          <strong>Choose the picture that replaces <em>?</em></strong>
          <div id="options" class="options" style="margin-top:10px"></div>
        </div>

        <div class="card">
          <strong>How it works</strong>
          <p class="muted" style="margin:.5rem 0 0">
            Each row/column follows simple visual rules (e.g., shape cycles across the row, color cycles down the column, size increases, or rotation increases).
            Pick the option that satisfies <b>both</b> row and column rules for the missing tile.
          </p>
          <div class="legend" style="margin-top:8px">
            <div class="tag">Tap a tile to answer</div>
            <div class="tag">Green = correct</div>
            <div class="tag">Red = wrong</div>
          </div>
        </div>

        
      </aside>
    </div>
  </div>

<script>
/* ========= Drawing primitives ========= */
const COLORS = ["#6ae3ff","#77ff9b","#ffd166","#ff6b6b","#a78bfa","#f472b6"];
const SHAPES = ["circle","triangle","square","pentagon","star","diamond"];

function drawShape(ctx, shape, size, color, rotation=0){
  const {width, height} = ctx.canvas;
  const cx = width/2, cy = height/2;
  const s = Math.min(width, height) * size;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rotation * Math.PI/180);
  ctx.fillStyle = color;
  ctx.strokeStyle = "rgba(255,255,255,.08)";
  ctx.lineWidth = Math.max(1, width*0.01);

  switch(shape){
    case "circle":
      ctx.beginPath(); ctx.arc(0,0,s*0.42,0,Math.PI*2); ctx.fill(); break;
    case "triangle":
      polygon(3); break;
    case "square":
      polygon(4); break;
    case "pentagon":
      polygon(5); break;
    case "star":
      star(5); break;
    case "diamond":
      diamond(); break;
  }
  ctx.stroke();
  ctx.restore();

  function polygon(n){
    const r = s*0.42;
    ctx.beginPath();
    for(let i=0;i<n;i++){
      const ang = -Math.PI/2 + i*2*Math.PI/n;
      const x = r*Math.cos(ang), y = r*Math.sin(ang);
      i? ctx.lineTo(x,y): ctx.moveTo(x,y);
    }
    ctx.closePath(); ctx.fill();
  }
  function star(points){
    const outer = s*0.42, inner = outer*0.45;
    ctx.beginPath();
    for(let i=0;i<points*2;i++){
      const r = (i%2===0)? outer : inner;
      const ang = -Math.PI/2 + i*Math.PI/points;
      const x=r*Math.cos(ang), y=r*Math.sin(ang);
      i? ctx.lineTo(x,y): ctx.moveTo(x,y);
    }
    ctx.closePath(); ctx.fill();
  }
  function diamond(){
    const r = s*0.44;
    ctx.beginPath();
    ctx.moveTo(0,-r); ctx.lineTo(r,0); ctx.lineTo(0,r); ctx.lineTo(-r,0); ctx.closePath(); ctx.fill();
  }
}

/* ========= Puzzle model =========
   A tile = {shape, color, size(0..1), rotation(deg)}
   Rules:
   - Across rows: cycle shape or add rotation or add size step
   - Down columns: cycle color or add rotation or add size step
*/
function makeTile(shape, color, size, rotation){ return {shape, color, size, rotation}; }
function cloneTile(t){ return {...t}; }

/* Generate a 3x3 puzzle and one correct missing tile */
function generatePuzzle(mode="mixed"){
  // pick base attributes
  const shapeSeq = pickCycle(SHAPES, 3);
  const colorSeq = pickCycle(COLORS, 3);
  const sizeBase = randRange(0.45, 0.75);
  const sizeStep = randRange(-0.12, 0.12);
  const rotBase = [0, 30, 45, 60, 90][Math.floor(Math.random()*5)];
  const rotStep = [15, 30, 45, 60][Math.floor(Math.random()*4)] * (Math.random()<0.5?1:-1);

  // decide rules
  let rowRule, colRule;
  switch(mode){
    case "shapeColor":
      rowRule = "shape"; colRule = "color"; break;
    case "shapeRotate":
      rowRule = "shape"; colRule = "rotation"; break;
    case "sizeColor":
      rowRule = "size";  colRule = "color"; break;
    default:
      // mixed: sample without replacement
      const pool = ["shape","size","rotation"];
      rowRule = pick(pool); pool.splice(pool.indexOf(rowRule),1);
      colRule = pick(["color", ...pool]); // color appears often
  }

  // build 3x3 grid
  const grid = Array.from({length:3}, ()=>Array.from({length:3}, ()=>null));
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      let shape = SHAPES[0], color = COLORS[0], size = sizeBase, rotation = rotBase;

      // row rule application
      if(rowRule==="shape")  shape = shapeSeq[c];
      if(rowRule==="size")   size  = clamp01(sizeBase + c*sizeStep);
      if(rowRule==="rotation") rotation = normAngle(rotBase + c*rotStep);

      // column rule application
      if(colRule==="color") color = colorSeq[r];
      if(colRule==="size")  size  = clamp01(sizeBase + r*sizeStep);
      if(colRule==="rotation") rotation = normAngle(rotBase + r*rotStep);

      // if both choose same channel (e.g., size+size), combine deltas
      if(rowRule==="size" && colRule==="size") size = clamp01(sizeBase + c*sizeStep + r*sizeStep);
      if(rowRule==="rotation" && colRule==="rotation") rotation = normAngle(rotBase + c*rotStep + r*rotStep);

      // if neither set shape/color, pick base cycles so there is variety
      if(rowRule!=="shape") shape = shapeSeq[(r+c)%shapeSeq.length];
      if(colRule!=="color") color = colorSeq[(r+c)%colorSeq.length];

      grid[r][c] = makeTile(shape, color, size, rotation);
    }
  }

  // remove one at random (usually bottom-right feels classic)
  const missingPos = Math.random() < 0.65 ? {r:2,c:2} : {r:randInt(0,2), c:randInt(0,2)};
  const correct = grid[missingPos.r][missingPos.c];
  grid[missingPos.r][missingPos.c] = null;

  // build 3 wrong options as plausible distractors
  const options = [correct,
    disturb(correct, rowRule, colRule, shapeSeq, colorSeq, sizeStep, rotStep, "shape"),
    disturb(correct, rowRule, colRule, shapeSeq, colorSeq, sizeStep, rotStep, "color"),
    disturb(correct, rowRule, colRule, shapeSeq, colorSeq, sizeStep, rotStep, Math.random()<0.5?"size":"rotation")
  ];
  shuffleInPlace(options);

  return { grid, missingPos, correct, options, rowRule, colRule };
}

/* Helpers for puzzle gen */
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
function randRange(a,b){ return a + Math.random()*(b-a); }
function clamp01(x){ return Math.max(0.3, Math.min(0.9, x)); }
function normAngle(a){ a%=360; if(a<0)a+=360; return a; }
function pickCycle(arr, n){
  const start = randInt(0, arr.length-1);
  const step = randInt(1, arr.length-1);
  const seq = [];
  for(let i=0;i<n;i++) seq.push(arr[(start + i*step) % arr.length]);
  // ensure at least two unique
  if(new Set(seq).size<2) return pickCycle(arr,n);
  return seq;
}
function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

function disturb(tile, rowRule, colRule, shapeSeq, colorSeq, sizeStep, rotStep, channel){
  const t = cloneTile(tile);
  if(channel==="shape"){
    let others = SHAPES.filter(s=>s!==t.shape);
    t.shape = pick(others);
  } else if(channel==="color"){
    let others = COLORS.filter(c=>c!==t.color);
    t.color = pick(others);
  } else if(channel==="size"){
    // nudge size the wrong way / different step
    t.size = clamp01(t.size + (Math.random()<0.5? 0.15 : -0.15));
  } else if(channel==="rotation"){
    t.rotation = normAngle(t.rotation + (Math.random()<0.5? rotStep*2 : rotStep/2 || 30));
  }
  return t;
}

/* ========= UI Rendering ========= */
const boardEl = document.getElementById('board');
const optsEl  = document.getElementById('options');
const timerEl = document.getElementById('timer');
const scoreEl = document.getElementById('score');
const puzNoEl = document.getElementById('puzNo');
const modeSel = document.getElementById('mode');
const nextBtn = document.getElementById('nextBtn');

let current, score=0, puzzleNo=1, lock=false;
let timerId, seconds=0;

function drawTile(container, tile, isMissing=false){
  container.className = 'tile' + (isMissing? ' missing':'');
  container.innerHTML = '';
  const cv = document.createElement('canvas');
  container.appendChild(cv);
  // size canvas to container
  const rect = container.getBoundingClientRect();
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  cv.width  = Math.floor(rect.width * dpr);
  cv.height = Math.floor(rect.width * dpr); // square
  cv.style.width = '100%'; cv.style.height = '100%';
  const ctx = cv.getContext('2d');
  // background grid flare
  ctx.fillStyle = "#0b1030"; ctx.fillRect(0,0,cv.width,cv.height);
  if(tile) drawShape(ctx, tile.shape, tile.size, tile.color, tile.rotation);
}

function renderPuzzle(){
  lock = false;
  boardEl.innerHTML = '';
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      const cell = document.createElement('div');
      cell.className = 'tile';
      boardEl.appendChild(cell);
      drawTile(cell, current.grid[r][c], current.grid[r][c]===null);
      if(current.grid[r][c]===null){
        cell.classList.add('missing');
      }
    }
  }
  // options

optsEl.innerHTML = '';
const labels = ['A','B','C','D'];

current.options.forEach((opt,i)=>{
    const wrap = document.createElement('div');
    wrap.className = 'opt';
    wrap.innerHTML = `<div class="label">${labels[i]}</div>`;

    const inner = document.createElement('div');
    inner.className = 'tile';
    wrap.appendChild(inner);

    optsEl.appendChild(wrap);          // append first
    drawTile(inner, opt, false);       // then draw

    wrap.addEventListener('click', ()=> chooseOption(wrap, opt));
});

}

function chooseOption(el, opt){
  if(lock) return;
  lock = true;
  const isCorrect = equalTile(opt, current.correct);
  el.classList.add(isCorrect? 'correct':'wrong');
  if(isCorrect){
    score++; scoreEl.textContent = score;
    // also mark the missing tile on the board
    const idx = 3*current.missingPos.r + current.missingPos.c;
    const missing = boardEl.children[idx];
    drawTile(missing, current.correct, false);
    pulse(el, 'correct');
  }else{
    pulse(el, 'wrong');
  }
  // brief pause then next
  setTimeout(nextPuzzle, 900);
}

function pulse(el, kind){
  el.animate(
    [{transform:'scale(1)'},{transform:'scale(1.03)'},{transform:'scale(1)'}],
    {duration:300, easing:'ease-out'}
  );
}

/* Shallow equality good enough for our attributes */
function equalTile(a,b){
  return a.shape===b.shape && a.color===b.color &&
         Math.abs(a.size-b.size) < 0.02 &&
         ((a.rotation-b.rotation+360)%360) < 2;
}

function nextPuzzle(){
  puzzleNo++; puzNoEl.textContent = puzzleNo;
  current = generatePuzzle(modeSel.value);
  renderPuzzle();
}

/* ========= Timer ========= */
function startTimer(){
  clearInterval(timerId); seconds=0; timerEl.textContent="00:00";
  timerId = setInterval(()=>{
    seconds++;
    const m=String(Math.floor(seconds/60)).padStart(2,'0');
    const s=String(seconds%60).padStart(2,'0');
    timerEl.textContent = `${m}:${s}`;
  },1000);
}

/* ========= Init ========= */
function init(){
  score=0; scoreEl.textContent=score; puzzleNo=1; puzNoEl.textContent=puzzleNo;
  current = generatePuzzle(modeSel.value);
  renderPuzzle(); startTimer();
}
nextBtn.addEventListener('click', ()=>{ nextPuzzle(); });
modeSel.addEventListener('change', ()=>{ init(); });

window.addEventListener('resize', ()=>{ renderPuzzle(); }); // redraw canvases to new size
init();
</script>
</body>
</html>
