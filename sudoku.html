<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sudoku</title>
<style>
  :root{
  --bg: #0f1222;
  --panel: #171a2f;
  --ink: #e7e9ff;
  --muted: #a8b0d3;
  --accent: #6ae3ff;
  --accent2:#77ff9b;
  --warn:#ffb703;
  --danger:#ff6b6b;
  --radius: 16px;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
}
*{box-sizing:border-box}
body{
  margin:0;
  min-height:100vh;
  display:grid;
  place-items:center;
  background:radial-gradient(1200px 600px at 20% -10%, #1b2042, #0f1222);
  font:500 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
  color:var(--ink);
}
.app{width:min(1100px,94vw)}
header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;margin-bottom:12px}
.brand{display:flex;align-items:center;gap:10px}
.brand .dot{width:14px;height:14px;border-radius:50%;background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 0 0 4px rgba(106,227,255,.15)}
.controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
select,button{
  background:var(--panel);
  color:var(--ink);
  border:1px solid rgba(255,255,255,.08);
  padding:10px 12px;
  border-radius:12px;
  outline:none;
  transition:.2s ease;
  box-shadow:inset 0 -12px 20px rgba(255,255,255,.02)
}
button.primary{background:linear-gradient(135deg,var(--accent),var(--accent2));color:#001720;border:none;font-weight:700}
button:hover,select:hover{transform:translateY(-1px);box-shadow:0 8px 18px rgba(0,0,0,.25)}

.layout{display:grid;grid-template-columns: 420px 1fr;gap:18px}
@media (max-width: 980px){
  .layout{grid-template-columns:1fr}
}

.card{
  background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
  padding:16px;
  border:1px solid rgba(255,255,255,.08);
  border-radius:var(--radius);
  box-shadow:var(--shadow)
}
.muted{color:var(--muted)}

/* Sudoku board */
.board{
  width:420px;
  max-width:94vw;
  aspect-ratio:1;
  border-radius:12px;
  background:#0a0c18;
  border:1px solid rgba(255,255,255,.08);
  display:grid;
  grid-template-columns:repeat(9,1fr);
  grid-template-rows:repeat(9,1fr);
  overflow:hidden
}
.cell{
  position:relative;
  border:1px solid rgba(255,255,255,.06);
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  font-size:22px;
  cursor:pointer;
  user-select:none
}
.cell[data-fixed="true"]{color:#a9e3ff}
.cell.selected{outline:2px solid var(--accent)}
.cell.same{background:rgba(106,227,255,.08)}
.cell.related{background:rgba(255,255,255,.03)}
.cell.conflict{background:rgba(255,0,0,.1)}
.cell .notes{
  position:absolute;
  inset:3px;
  display:grid;
  grid-template-columns:repeat(3,1fr);
  grid-template-rows:repeat(3,1fr);
  gap:2px;
  font-size:12px;
  color:#96a0cc
}
.cell .notes span{display:flex;align-items:center;justify-content:center;opacity:.9}
.cell.invalid{color:var(--danger)}
/* thick subgrid borders */
.cell:nth-child(3n+1){border-left-width:2px}
.cell{border-right-width:1px}
.cell{border-bottom-width:1px}
.row-0 .cell, .row-3 .cell, .row-6 .cell{border-top-width:2px}
.col-0{border-left-width:2px}
.col-2, .col-5{border-right-width:2px}
.row-2 .cell, .row-5 .cell{border-bottom-width:2px}

.side{display:grid;gap:12px;align-content:start}
.row{display:flex;gap:8px;flex-wrap:wrap}
.kbd{background:#12162a;border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:8px 10px}

.number-pad{
  display:grid;
  grid-template-columns:repeat(5,1fr);
  gap:8px
}
.number-pad button{padding:12px 0;font-size:16px}

.footer{text-align:center;color:var(--muted);font-size:13px;margin-top:10px}
.stat{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:10px 12px;
  background:var(--panel);
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08)
}

/* ðŸ“± Responsive tweaks */
@media (max-width: 600px){
  .board{width:100%;max-width:100%;}
  .cell{font-size:18px}
  .number-pad{grid-template-columns:repeat(3,1fr)}
  .number-pad button{padding:10px 0;font-size:14px}
  header{flex-direction:column;align-items:flex-start}
}

@media (max-width: 400px){
  .cell{font-size:14px}
  .number-pad{grid-template-columns:repeat(2,1fr)}
  .number-pad button{font-size:13px;padding:8px 0}
  .controls{flex-direction:column;align-items:stretch}
}

</style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand"><span class="dot"></span><strong>Sudoku</strong></div>
      <div class="controls">
        <label class="muted">Difficulty</label>
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
          <option value="expert">Expert</option>
        </select>
        <button class="primary" id="newBtn">New Puzzle</button>
        <button id="checkBtn">Check</button>
        <button id="hintBtn">Hint</button>
        <button id="solveBtn">Solve</button>
        <button id="clearBtn">Clear</button>
        <button id="notesBtn">Notes: Off</button>
      </div>
    </header>

    <div class="layout">
       <div class="card stat"><span>Time</span><strong id="timer">00:00</strong></div>
        <div class="card stat"><span>Errors</span><strong id="errors">0</strong></div>
       
      <section class="card">
        <div id="board" class="board" aria-label="Sudoku board"></div>
      </section>

      <aside class="side">
       
        <div class="card">
          <strong>Number pad</strong>
          <div class="number-pad" id="numPad"></div>
        </div>
         <div class="card">
          <strong>How to play</strong>
          <p class="muted" style="margin:.5rem 0 0">Click a cell and type <span class="kbd">1â€“9</span> to fill. Use arrows to move, <span class="kbd">Del/Backspace</span> to clear. Toggle <b>Notes</b> to add pencil marks. Conflicts highlight automatically.</p>
        </div>
       
      </aside>
    </div>
  </div>

  <script>
    // --- Utilities ----------------------------------------------------------
    const range = n => [...Array(n).keys()];
    const deepCopy = obj => JSON.parse(JSON.stringify(obj));

    // Board state
    let solution = createEmpty();
    let puzzle = createEmpty();
    let fixed = createEmpty(false);
    let notes = range(9).map(()=>range(9).map(()=>new Set()));
    let selected = {r:0,c:0};
    let notesMode = false;
    let errors = 0;
    let timerId; let seconds=0;

    function createEmpty(fill=0){ return range(9).map(()=>range(9).map(()=>fill)); }

    // --- Sudoku generation/solving -----------------------------------------
    function isSafe(board, r, c, val){
      for(let i=0;i<9;i++) if(board[r][i]===val || board[i][c]===val) return false;
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(board[br+i][bc+j]===val) return false;
      return true;
    }

    function solveBoard(board){
      for(let r=0;r<9;r++){
        for(let c=0;c<9;c++){
          if(board[r][c]===0){
            for(let n=1;n<=9;n++){
              if(isSafe(board,r,c,n)){
                board[r][c]=n;
                if(solveBoard(board)) return true;
                board[r][c]=0;
              }
            }
            return false;
          }
        }
      }
      return true;
    }

    function countSolutions(board, limit=2){
      let count=0;
      function backtrack(){
        for(let r=0;r<9;r++){
          for(let c=0;c<9;c++){
            if(board[r][c]===0){
              for(let n=1;n<=9;n++){
                if(isSafe(board,r,c,n)){
                  board[r][c]=n; backtrack(); board[r][c]=0; if(count>=limit) return; 
                }
              }
              return; // no candidate
            }
          }
        }
        count++;
      }
      backtrack();
      return count;
    }

    function generateCompleted(){
      const board=createEmpty();
      // Seed first row with shuffled 1-9 then backtrack
      const nums=range(9).map(i=>i+1).sort(()=>Math.random()-0.5);
      for(let c=0;c<9;c++) board[0][c]=nums[c];
      solveBoard(board);
      return board;
    }

    function makePuzzleFrom(solution, difficulty){
      const cluesByDiff = { easy: 40, medium: 32, hard: 26, expert: 22 };
      let clues = cluesByDiff[difficulty] ?? 32;
      const board = deepCopy(solution);
      // positions 0..80
      const positions = range(81).sort(()=>Math.random()-0.5);
      // Remove cells while preserving unique solution
      let removed = 0;
      for(const pos of positions){
        const r=Math.floor(pos/9), c=pos%9;
        if(board[r][c]===0) continue;
        const backup = board[r][c];
        board[r][c]=0;
        const copy=deepCopy(board);
        const solCount = countSolutions(copy,2);
        if(solCount!==1){
          board[r][c]=backup; // revert; uniqueness lost
        }else{
          removed++;
          if(81-removed<=clues) break;
        }
      }
      return board;
    }

    // --- Rendering ----------------------------------------------------------
    const boardEl = document.getElementById('board');
    const timerEl = document.getElementById('timer');
    const errorsEl = document.getElementById('errors');

    function buildBoard(){
      boardEl.innerHTML='';
      for(let r=0;r<9;r++){
        const row = document.createElement('div');
        row.className = `row-${r}`;
        for(let c=0;c<9;c++){
          const cell = document.createElement('div');
          cell.className = `cell col-${c}`;
          cell.tabIndex=0;
          cell.dataset.r=r; cell.dataset.c=c;
          cell.addEventListener('click', ()=>selectCell(r,c));
          cell.addEventListener('focus', ()=>selectCell(r,c));
          boardEl.appendChild(cell);
        }
      }
      paint();
    }

    function paint(){
      for(const cell of boardEl.children){
        const r=+cell.dataset.r, c=+cell.dataset.c;
        const val=puzzle[r][c];
        cell.classList.remove('selected','same','related','conflict','invalid');
        cell.textContent = val? String(val):'';
        cell.dataset.fixed = fixed[r][c] ? 'true' : 'false';
        // notes
        const hasNotes = notes[r][c].size>0 && !val;
        if(hasNotes){
          const wrap = document.createElement('div');
          wrap.className='notes';
          for(let n=1;n<=9;n++){
            const s=document.createElement('span');
            s.textContent = notes[r][c].has(n)? n : '';
            wrap.appendChild(s);
          }
          cell.appendChild(wrap);
        }
      }
      highlight();
    }

    function highlight(){
      const {r,c}=selected;
      for(const cell of boardEl.children){
        const rr=+cell.dataset.r, cc=+cell.dataset.c;
        if(rr===r && cc===c) cell.classList.add('selected');
        if(rr===r || cc===c || (Math.floor(rr/3)===Math.floor(r/3) && Math.floor(cc/3)===Math.floor(c/3))) cell.classList.add('related');
        const v = puzzle[rr][cc];
        if(v && v===puzzle[r][c]) cell.classList.add('same');
        // conflicts
        if(v && hasConflict(rr,cc,v)) cell.classList.add('conflict');
      }
    }

    function hasConflict(r,c,val){
      for(let i=0;i<9;i++) if(i!==c && puzzle[r][i]===val) return true;
      for(let i=0;i<9;i++) if(i!==r && puzzle[i][c]===val) return true;
      const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
      for(let i=0;i<3;i++) for(let j=0;j<3;j++){
        const rr=br+i, cc=bc+j; if(rr===r && cc===c) continue; if(puzzle[rr][cc]===val) return true;}
      return false;
    }

    function selectCell(r,c){ selected={r,c}; paint(); }

    function placeNumber(n){
      const {r,c}=selected; if(fixed[r][c]) return;
      if(notesMode){
        if(n===0){ notes[r][c].clear(); } else { notes[r][c].has(n)? notes[r][c].delete(n): notes[r][c].add(n); }
      }else{
        puzzle[r][c]=n; notes[r][c].clear();
        if(n!==0){
          if(hasConflict(r,c,n)){ errors++; errorsEl.textContent=errors; }
        }
      }
      paint();
      if(isComplete()) onWin();
    }

    function isComplete(){
      for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(puzzle[r][c]===0) return false;
      // verify equals solution
      for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(puzzle[r][c]!==solution[r][c]) return false;
      return true;
    }

    // --- Controls -----------------------------------------------------------
    document.getElementById('newBtn').addEventListener('click', newPuzzle);
    document.getElementById('checkBtn').addEventListener('click', checkBoard);
    document.getElementById('solveBtn').addEventListener('click', solveAll);
    document.getElementById('clearBtn').addEventListener('click', ()=>{ notes = range(9).map(()=>range(9).map(()=>new Set())); paint(); });
    document.getElementById('notesBtn').addEventListener('click', ()=>{ notesMode=!notesMode; document.getElementById('notesBtn').textContent = `Notes: ${notesMode? 'On':'Off'}`; });
    document.getElementById('hintBtn').addEventListener('click', giveHint);

    // Number pad
    const numPad = document.getElementById('numPad');
    for(let n=1;n<=9;n++){
      const b=document.createElement('button'); b.textContent=n; b.addEventListener('click',()=>placeNumber(n)); numPad.appendChild(b);
    }
    const del=document.createElement('button'); del.textContent='Del'; del.addEventListener('click',()=>placeNumber(0)); numPad.appendChild(del);

    // Keyboard input
    document.addEventListener('keydown', (e)=>{
      const {r,c}=selected;
      if(e.key>='1' && e.key<='9'){ placeNumber(+e.key); return; }
      if(['Backspace','Delete','0'].includes(e.key)){ placeNumber(0); return; }
      if(e.key==='ArrowUp') { selectCell((r+8)%9,c); }
      if(e.key==='ArrowDown'){ selectCell((r+1)%9,c); }
      if(e.key==='ArrowLeft'){ selectCell(r,(c+8)%9); }
      if(e.key==='ArrowRight'){ selectCell(r,(c+1)%9); }
      if(e.key.toLowerCase()==='n'){ notesMode=!notesMode; document.getElementById('notesBtn').textContent = `Notes: ${notesMode? 'On':'Off'}`; }
    });

    function checkBoard(){
      // Mark incorrect entries
      for(let r=0;r<9;r++) for(let c=0;c<9;c++){
        const idx = r*9+c; const el = boardEl.children[idx];
        el.classList.toggle('invalid', puzzle[r][c]!==0 && puzzle[r][c]!==solution[r][c]);
      }
    }

    function solveAll(){ puzzle = deepCopy(solution); paint(); onWin(true); }

    function giveHint(){
      // fill one random empty cell with correct value
      const empties=[]; for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(puzzle[r][c]===0) empties.push({r,c});
      if(!empties.length) return;
      const pick = empties[Math.floor(Math.random()*empties.length)];
      puzzle[pick.r][pick.c]=solution[pick.r][pick.c]; fixed[pick.r][pick.c]=false; notes[pick.r][pick.c].clear();
      selectCell(pick.r,pick.c);
      paint();
      if(isComplete()) onWin();
    }

    function newPuzzle(){
      stopTimer(); seconds=0; timerEl.textContent='00:00'; errors=0; errorsEl.textContent='0';
      notes = range(9).map(()=>range(9).map(()=>new Set()));
      const diff = document.getElementById('difficulty').value;
      solution = generateCompleted();
      puzzle = makePuzzleFrom(solution, diff);
      fixed = range(9).map((r)=>range(9).map((c)=> puzzle[r][c]!==0));
      buildBoard();
      startTimer();
    }

    function startTimer(){
      timerId = setInterval(()=>{ seconds++; const m=String(Math.floor(seconds/60)).padStart(2,'0'); const s=String(seconds%60).padStart(2,'0'); timerEl.textContent=`${m}:${s}`; },1000);
    }
    function stopTimer(){ clearInterval(timerId); }

    function onWin(fromSolve=false){
      stopTimer();
      // simple celebration
      confetti(150);
      setTimeout(()=>{ alert(fromSolve? 'Solved! (Auto)':'You solved it!'); }, 50);
    }

    // tiny confetti
    function confetti(n){
      const container = document.createElement('div');
      container.style.position='fixed';container.style.inset='0';container.style.pointerEvents='none';document.body.appendChild(container);
      for(let i=0;i<n;i++){
        const d=document.createElement('div');
        d.style.position='absolute';d.style.width='8px';d.style.height='12px';
        d.style.background=`hsl(${Math.random()*360},100%,60%)`; d.style.top='-20px'; d.style.left=Math.random()*100+'%';
        container.appendChild(d);
        let y=-20, x=parseFloat(d.style.left);
        const fall=setInterval(()=>{ y+=4+Math.random()*4; x+=Math.random()*2-1; d.style.transform=`translate(${x}vw, ${y}px) rotate(${y*4}deg)`; if(y>window.innerHeight){clearInterval(fall); d.remove(); if(!container.childElementCount) container.remove();}}, 16);
      }
    }

    // Initialize
    newPuzzle();
  </script>
</body>
</html>
